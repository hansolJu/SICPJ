// 목적 프로그램의 시작 메모리 주소는 1000번지 => COPY START 1000
//연상 연산 코드를 동등한 기계어로 전환 => OPTAB 이용
//심벌 피연산자를 동등한 기계주소로 전환 => SYMTAB 이용
//기계 명령어를 적당한 형식에 맞추어서 생성 => 직접/인덱스 주소 지정 방식
//원시 프로그램에 나타난 데이타 상수를 기계 내부 표현으로 전환 => 필요한 만큼의 문자(C'...'), 16진수(X'...')상수
//목적 프로그램과 어셈블러 리스트를 작성

//패스 1
//1. 프로그램내의 모든문에 주소를 배정
//2. 패스 2에서 사용하기 위해 모든 레이블에 배정된 주소 값들을 저장 =>SYMTAB
//3. 어셈블러 지시자들에 관련된 처리를 부분적으로 처리 => BYTE, RESW 등과 같은 주소 배정에 영향을 주는 처리를 포함

//패스 2
//1. 명령어를 어셈블 => 연산자 코드를 번역하고(OPTAB), 주소를 조사
//2. BYTE, WORD등으로 정의되는 데이타 값을 생성
//3. 패스 1 동안에 이루어지지 않는 어셈블러 지시자의 처리
//4. 목적 프로그램과 어셈블러 리스트를 출력

//OPTAB: 연상 명령어를 찾아서 기계어를 번역하는데 사용
//1. 적어도 명령어 코드와 해당되는 기계 코들를 포함
//2. 명령어 형식과 길이에 대한 정보를 포함하기도 함(서로 다른 명령어를 갖는 기계)
//3. 패스 1에서 원시 프로그램의 명령 코드를 조사하고 확인하는데 사용
//4. 패스 2에서 명령어를 기계어로 번역하는데 사용
//5. 보통 연상 명령어 코드를 키로 갖는 해쉬 테이블로 구성
//6. 내용은 실행 시간에 테이블로 로드되는 것이 아니라, 어셈블러가 작성될때 미리 정의됨
//7. 명령 코드가 추가 또는 삭제될 필요가 없기 때분에 대부분 정적 테이블로 구성

//SYMTAB: 레이블에 배정된 값을 저장하는데 사용
//1. 원시 프로그램의 각 레이블의 이름과 값(주소), 오류 상태(한 기호가 두 장소에서 정의되는 경우)를 나타내기 위한 플래그를 포함
//2. 레이블이 붙여진 데이타 영역이나 명령의 종류, 길이 등에 대한 정보도 포함할 수 있음
//3. 패스 1에서 레이블은 배정되는 주소와 함께 입력
//4. 패스 2에서 피연산자로 사용된 기호는 SYMTAB를 조사하여 어셈블된 명령어에 삽입하기 위한 주소를 찾음
//5. 삽입과 검색의 효율을 위해 보통 해쉬 테이블로 구성

//LOCCTR: 주소 배정을 처리하기 위한 변수 
//1. START문에서 나타낸 시작 주소로 초기화
//2. 각 원시 문장이 나타날 때마다 어셈블된 명령어나 생성된 데이타 영역의 길이가 더해짐
//3. 원시 프로그램에서 레이블을 만날 때 마다 LOCCTR의 현재 값을 레이블의 주소로 배정

//중간화일: 패스 1동안에 수행되어지는 작업을 보존하기 위해 사용
//1. 패스 1은 보통 원시 프로그램과 함께 배정된 주소, 오류 플래그등을 포함하며 패스 2에서 입력으로 사용
//2. OPTAB과 SYMTAB을 가리키는 포인터를 각각 사용되는 연산 코드와 기호에 보존시킴으로써 테이블 탐색의 중복을 피할수 있도록 함

//Sorce DATA
//1. 원시 프로그램은 LABEL, OPCOE와 OPERAND 필드의 고정된 형식으로 작성된다고 가정
//2. 이 필드중의 하나가 수를 표현하는 문자열을 포함하면 접두 문자로 '#'과 함께 그 수의 값을 나타냄 
//3. 모듈 - 기호 테이블의 탐색, 원시 프로그램 읽기


/*
* 한 라인은 분리자로 구분된 토큰에 따라
1개: OPCODE
2개: OPCODE OPERAND
3개: LABEL OPCODE OPERAND
* 피연산자가 ,로 구분된 2개인 경우 붙여 씀 ex) addr r1,r2
*/


